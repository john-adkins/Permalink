{"ts":1353144015465,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// Copyright 2010-2012 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\nvar http = require('http')\n  , https = false\n  , tls = false\n  , url = require('url')\n  , util = require('util')\n  , stream = require('stream')\n  , qs = require('querystring')\n  , oauth = require('./oauth')\n  , uuid = require('./uuid')\n  , ForeverAgent = require('./forever')\n  , Cookie = require('./vendor/cookie')\n  , CookieJar = require('./vendor/cookie/jar')\n  , cookieJar = new CookieJar\n  , tunnel = require('./tunnel')\n  , aws = require('./aws')\n  \n  , mime = require('mime')\n  , FormData = require('form-data')\n  ;\n  \nif (process.logging) {\n  var log = process.logging('request')\n}\n\ntry {\n  https = require('https')\n} catch (e) {}\n\ntry {\n  tls = require('tls')\n} catch (e) {}\n\nfunction toBase64 (str) {\n  return (new Buffer(str || \"\", \"ascii\")).toString(\"base64\")\n}\n\n// Hacky fix for pre-0.4.4 https\nif (https && !https.Agent) {\n  https.Agent = function (options) {\n    http.Agent.call(this, options)\n  }\n  util.inherits(https.Agent, http.Agent)\n  https.Agent.prototype._getConnection = function (host, port, cb) {\n    var s = tls.connect(port, host, this.options, function () {\n      // do other checks here?\n      if (cb) cb()\n    })\n    return s\n  }\n}\n\nfunction isReadStream (rs) {\n  if (rs.readable && rs.path && rs.mode) {\n    return true\n  }\n}\n\nfunction copy (obj) {\n  var o = {}\n  Object.keys(obj).forEach(function (i) {\n    o[i] = obj[i]\n  })\n  return o\n}\n\nvar isUrl = /^https?:/\n\nvar globalPool = {}\n\nfunction Request (options) {\n  stream.Stream.call(this)\n  this.readable = true\n  this.writable = true\n\n  if (typeof options === 'string') {\n    options = {uri:options}\n  }\n  \n  var reserved = Object.keys(Request.prototype)\n  for (var i in options) {\n    if (reserved.indexOf(i) === -1) {\n      this[i] = options[i]\n    } else {\n      if (typeof options[i] === 'function') {\n        delete options[i]\n      }\n    }\n  }\n  options = copy(options)\n  \n  this.init(options)\n}\nutil.inherits(Request, stream.Stream)\nRequest.prototype.init = function (options) {\n  var self = this\n  \n  if (!options) options = {}\n  if (process.env.NODE_DEBUG && /request/.test(process.env.NODE_DEBUG)) console.error('REQUEST', options)\n  if (!self.pool && self.pool !== false) self.pool = globalPool\n  self.dests = []\n  self.__isRequestRequest = true\n  \n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) return // Print a warning maybe?\n      self._callback.apply(self, arguments)\n      self._callbackCalled = true\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  if (self.url) {\n    // People use this property instead all the time so why not just support it.\n    self.uri = self.url\n    delete self.url\n  }\n\n  if (!self.uri) {\n    // this will throw if unhandled but is handleable when in a redirect\n    return self.emit('error', new Error(\"options.uri is a required argument\"))\n  } else {\n    if (typeof self.uri == \"string\") self.uri = url.parse(self.uri)\n  }\n  if (self.proxy) {\n    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy)\n\n    // do the HTTP CONNECT dance using koichik/node-tunnel\n    if (http.globalAgent && self.uri.protocol === \"https:\") {\n      var tunnelFn = self.proxy.protocol === \"http:\"\n                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps\n\n      var tunnelOptions = { proxy: { host: self.proxy.hostname\n                                   , port: +self.proxy.port\n                                   , proxyAuth: self.proxy.auth }\n                          , ca: this.ca }\n\n      self.agent = tunnelFn(tunnelOptions)\n      self.tunnel = true\n    }\n  }\n\n  if (!self.uri.host || !self.uri.pathname) {\n    // Invalid URI: it may generate lot of bad errors, like \"TypeError: Cannot call method 'indexOf' of undefined\" in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri)\n    var message = 'Invalid URI \"' + faultyUri + '\"'\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (he didn't call request directly with this URL)\n      // he should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.'\n    }\n    self.emit('error', new Error(message))\n    return // This error was fatal\n  }\n\n  self._redirectsFollowed = self._redirectsFollowed || 0\n  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10\n  self.followRedirect = (self.followRedirect !== undefined) ? self.followRedirect : true\n  self.followAllRedirects = (self.followAllRedirects !== undefined) ? self.followAllRedirects : false\n  if (self.followRedirect || self.followAllRedirects)\n    self.redirects = self.redirects || []\n\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  self.setHost = false\n  if (!self.headers.host) {\n    self.headers.host = self.uri.hostname\n    if (self.uri.port) {\n      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&\n           !(self.uri.port === 443 && self.uri.protocol === 'https:') )\n      self.headers.host += (':'+self.uri.port)\n    }\n    self.setHost = true\n  }\n  \n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.pathname) {self.uri.pathname = '/'}\n  if (!self.uri.port) {\n    if (self.uri.protocol == 'http:') {self.uri.port = 80}\n    else if (self.uri.protocol == 'https:') {self.uri.port = 443}\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  self.clientErrorHandler = function (error) {\n    if (self._aborted) return\n    \n    if (self.setHost) delete self.headers.host\n    if (self.req._reusedSocket && error.code === 'ECONNRESET'\n        && self.agent.addRequestNoreuse) {\n      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n      self.start()\n      self.req.end()\n      return\n    }\n    if (self.timeout && self.timeoutTimer) {\n      clearTimeout(self.timeoutTimer)\n      self.timeoutTimer = null\n    }\n    self.emit('error', error)\n  }\n\n  self._parserErrorHandler = function (error) {\n    if (this.res) {\n      if (this.res.request) {\n        this.res.request.emit('error', error)\n      } else {\n        this.res.emit('error', error)\n      }\n    } else {\n      this._httpMessage.emit('error', error)\n    }\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  }\n  \n  if (options.aws) {\n    self.aws(options.aws)\n  }\n\n  if (self.uri.auth && !self.headers.authorization) {\n    self.headers.authorization = \"Basic \" + toBase64(self.uri.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))\n  }\n  if (self.proxy && self.proxy.auth && !self.headers['proxy-authorization'] && !self.tunnel) {\n    self.headers['proxy-authorization'] = \"Basic \" + toBase64(self.proxy.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))\n  }\n\n  if (options.qs) self.qs(options.qs)\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || \"\")\n  }\n\n  if (self.path.length === 0) self.path = '/'\n\n  if (self.proxy && !self.tunnel) self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n\n  if (options.json) {\n    self.json(options.json)\n  } else if (options.multipart) {\n    self.boundary = uuid()\n    self.multipart(options.multipart)\n  }\n\n  if (self.body) {\n    var length = 0\n    if (!Buffer.isBuffer(self.body)) {\n      if (Array.isArray(self.body)) {\n        for (var i = 0; i < self.body.length; i++) {\n          length += self.body[i].length\n        }\n      } else {\n        self.body = new Buffer(self.body)\n        length = self.body.length\n      }\n    } else {\n      length = self.body.length\n    }\n    if (length) {\n      if(!self.headers['content-length'] && !self.headers['Content-Length'])\n      self.headers['content-length'] = length\n    } else {\n      throw new Error('Argument error, options.body.')\n    }\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n    , defaultModules = {'http:':http, 'https:':https}\n    , httpModules = self.httpModules || {}\n    ;\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) return this.emit('error', new Error(\"Invalid protocol\"))\n\n  if (options.ca) self.ca = options.ca\n\n  if (!self.agent) {\n    if (options.agentOptions) self.agentOptions = options.agentOptions\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getAgent()\n    if (self.maxSockets) {\n      // Don't use our pooling if node has the refactored client\n      self.agent.maxSockets = self.maxSockets\n    }\n    if (self.pool.maxSockets) {\n      // Don't use our pooling if node has the refactored client\n      self.agent.maxSockets = self.pool.maxSockets\n    }\n  }\n\n  self.once('pipe', function (src) {\n    if (self.ntick && self._started) throw new Error(\"You cannot pipe to this stream after the outbound request has started.\")\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.headers['content-type'] && !self.headers['Content-Type'])\n        self.headers['content-type'] = mime.lookup(src.path)\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.headers[i]) {\n            self.headers[i] = src.headers[i]\n          }\n        }\n      }\n      if (self._json && !self.headers['content-type'] && !self.headers['Content-Type'])\n        self.headers['content-type'] = 'application/json'\n      if (src.method && !self.method) {\n        self.method = src.method\n      }\n    }\n\n    self.on('pipe', function () {\n      console.error(\"You have already piped to this stream. Pipeing twice is likely to break the request.\")\n    })\n  })\n\n  process.nextTick(function () {\n    if (self._aborted) return\n    \n    if (self._form) {\n      self.setHeaders(self._form.getHeaders())\n      self._form.pipe(self)\n    }\n    if (self.body) {\n      if (Array.isArray(self.body)) {\n        self.body.forEach(function (part) {\n          self.write(part)\n        })\n      } else {\n        self.write(self.body)\n      }\n      self.end()\n    } else if (self.requestBodyStream) {\n      console.warn(\"options.requestBodyStream is deprecated, please pass the request object to stream.pipe.\")\n      self.requestBodyStream.pipe(self)\n    } else if (!self.src) {\n      if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n        self.headers['content-length'] = 0\n      }\n      self.end()\n    }\n    self.ntick = true\n  })\n}\n\n// Must call this when following a redirect from https to http or vice versa\n// Attempts to keep everything as identical as possible, but update the\n// httpModule, Tunneling agent, and/or Forever Agent in use.\nRequest.prototype._updateProtocol = function () {\n  var self = this\n  var protocol = self.uri.protocol\n\n  if (protocol === 'https:') {\n    // previously was doing http, now doing https\n    // if it's https, then we might need to tunnel now.\n    if (self.proxy) {\n      self.tunnel = true\n      var tunnelFn = self.proxy.protocol === 'http:'\n                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps\n      var tunnelOptions = { proxy: { host: self.proxy.hostname\n                                   , post: +self.proxy.port\n                                   , proxyAuth: self.proxy.auth }\n                          , ca: self.ca }\n      self.agent = tunnelFn(tunnelOptions)\n      return\n    }\n\n    self.httpModule = https\n    switch (self.agentClass) {\n      case ForeverAgent:\n        self.agentClass = ForeverAgent.SSL\n        break\n      case http.Agent:\n        self.agentClass = https.Agent\n        break\n      default:\n        // nothing we can do.  Just hope for the best.\n        return\n    }\n\n    // if there's an agent, we need to get a new one.\n    if (self.agent) self.agent = self.getAgent()\n\n  } else {\n    if (log) log('previously https, now http')\n    // previously was doing https, now doing http\n    // stop any tunneling.\n    if (self.tunnel) self.tunnel = false\n    self.httpModule = http\n    switch (self.agentClass) {\n      case ForeverAgent.SSL:\n        self.agentClass = ForeverAgent\n        break\n      case https.Agent:\n        self.agentClass = http.Agent\n        break\n      default:\n        // nothing we can do.  just hope for the best\n        return\n    }\n\n    // if there's an agent, then get a new one.\n    if (self.agent) {\n      self.agent = null\n      self.agent = self.getAgent()\n    }\n  }\n}\n\nRequest.prototype.getAgent = function () {\n  var Agent = this.agentClass\n  var options = {}\n  if (this.agentOptions) {\n    for (var i in this.agentOptions) {\n      options[i] = this.agentOptions[i]\n    }\n  }\n  if (this.ca) options.ca = this.ca\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== this.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  if (!this.httpModule.globalAgent) {\n    // node 0.4.x\n    options.host = this.host\n    options.port = this.port\n    if (poolKey) poolKey += ':'\n    poolKey += this.host + ':' + this.port\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = this.proxy\n  if (typeof proxy === 'string') proxy = url.parse(proxy)\n  var caRelevant = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n  if (options.ca && caRelevant) {\n    if (poolKey) poolKey += ':'\n    poolKey += options.ca\n  }\n\n  if (!poolKey && Agent === this.httpModule.Agent && this.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return this.httpModule.globalAgent\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = this.uri.protocol + poolKey\n\n  // already generated an agent for this setting\n  if (this.pool[poolKey]) return this.pool[poolKey]\n\n  return this.pool[poolKey] = new Agent(options)\n}\n\nRequest.prototype.start = function () {\n  var self = this\n\n  if (self._aborted) return\n\n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n  if (log) log('%method %href', self)\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.headers['content-length'] && !self.headers['Content-Length']) {\n    self.headers['content-length'] = self.src.stat.size\n  }\n  if (self._aws) {\n    self.aws(self._aws, true)\n  }\n  self.req = self.httpModule.request(self, function (response) {\n    if (response.connection.listeners('error').indexOf(self._parserErrorHandler) === -1) {\n      response.connection.once('error', self._parserErrorHandler)\n    }\n    if (self._aborted) return\n    if (self._paused) response.pause()\n\n    self.response = response\n    response.request = self\n    response.toJSON = toJSON\n\n    if (self.httpModule === https &&\n        self.strictSSL &&\n        !response.client.authorized) {\n      var sslErr = response.client.authorizationError\n      self.emit('error', new Error('SSL Error: '+ sslErr))\n      return\n    }\n\n    if (self.setHost) delete self.headers.host\n    if (self.timeout && self.timeoutTimer) {\n      clearTimeout(self.timeoutTimer)\n      self.timeoutTimer = null\n    }  \n\n    var addCookie = function (cookie) {\n      if (self._jar) self._jar.add(new Cookie(cookie))\n      else cookieJar.add(new Cookie(cookie))\n    }\n\n    if (response.headers['set-cookie'] && (!self._disableCookies)) {\n      if (Array.isArray(response.headers['set-cookie'])) response.headers['set-cookie'].forEach(addCookie)\n      else addCookie(response.headers['set-cookie'])\n    }\n\n    if (response.statusCode >= 300 && response.statusCode < 400  &&\n        (self.followAllRedirects ||\n         (self.followRedirect && (self.method !== 'PUT' && self.method !== 'POST' && self.method !== 'DELETE'))) &&\n        response.headers.location) {\n      if (self._redirectsFollowed >= self.maxRedirects) {\n        self.emit('error', new Error(\"Exceeded maxRedirects. Probably stuck in a redirect loop \"+self.uri.href))\n        return\n      }\n      self._redirectsFollowed += 1\n\n      if (!isUrl.test(response.headers.location)) {\n        response.headers.location = url.resolve(self.uri.href, response.headers.location)\n      }\n\n      var uriPrev = self.uri\n      self.uri = url.parse(response.headers.location)\n\n      // handle the case where we change protocol from https to http or vice versa\n      if (self.uri.protocol !== uriPrev.protocol) {\n        self._updateProtocol()\n      }\n\n      self.redirects.push(\n        { statusCode : response.statusCode\n        , redirectUri: response.headers.location \n        }\n      )\n      if (self.followAllRedirects) self.method = 'GET'\n      // self.method = 'GET' // Force all redirects to use GET || commented out fixes #215\n      delete self.src\n      delete self.req\n      delete self.agent\n      delete self._started\n      delete self.body\n      delete self._form\n      if (self.headers) {\n        delete self.headers.host\n        delete self.headers['content-type']\n        delete self.headers['content-length']\n      }\n      if (log) log('Redirect to %uri', self)\n      self.init()\n      return // Ignore the rest of the response\n    } else {\n      self._redirectsFollowed = self._redirectsFollowed || 0\n      // Be a good stream and emit end when the response is finished.\n      // Hack to emit end on close because of a core bug that never fires end\n      response.on('close', function () {\n        if (!self._ended) self.response.emit('end')\n      })\n\n      if (self.encoding) {\n        if (self.dests.length !== 0) {\n          console.error(\"Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.\")\n        } else {\n          response.setEncoding(self.encoding)\n        }\n      }\n\n      self.dests.forEach(function (dest) {\n        self.pipeDest(dest)\n      })\n\n      response.on(\"data\", function (chunk) {\n        self._destdata = true\n        self.emit(\"data\", chunk)\n      })\n      response.on(\"end\", function (chunk) {\n        self._ended = true\n        self.emit(\"end\", chunk)\n      })\n      response.on(\"close\", function () {self.emit(\"close\")})\n\n      self.emit('response', response)\n\n      if (self.callback) {\n        var buffer = []\n        var bodyLen = 0\n        self.on(\"data\", function (chunk) {\n          buffer.push(chunk)\n          bodyLen += chunk.length\n        })\n        self.on(\"end\", function () {\n          if (self._aborted) return\n          \n          if (buffer.length && Buffer.isBuffer(buffer[0])) {\n            var body = new Buffer(bodyLen)\n            var i = 0\n            buffer.forEach(function (chunk) {\n              chunk.copy(body, i, 0, chunk.length)\n              i += chunk.length\n            })\n            if (self.encoding === null) {\n              response.body = body\n            } else {\n              response.body = body.toString(self.encoding)\n            }\n          } else if (buffer.length) {\n            response.body = buffer.join('')\n          }\n\n          if (self._json) {\n            try {\n              response.body = JSON.parse(response.body)\n            } catch (e) {}\n          }\n          \n          self.emit('complete', response, response.body)\n        })\n      }\n    }\n  })\n\n  if (self.timeout && !self.timeoutTimer) {\n    self.timeoutTimer = setTimeout(function () {\n      self.req.abort()\n      var e = new Error(\"ETIMEDOUT\")\n      e.code = \"ETIMEDOUT\"\n      self.emit(\"error\", e)\n    }, self.timeout)\n    \n    // Set additional timeout on socket - in case if remote\n    // server freeze after sending headers\n    if (self.req.setTimeout) { // only works on node 0.6+\n      self.req.setTimeout(self.timeout, function () {\n        if (self.req) {\n          self.req.abort()\n          var e = new Error(\"ESOCKETTIMEDOUT\")\n          e.code = \"ESOCKETTIMEDOUT\"\n          self.emit(\"error\", e)\n        }\n      })\n    }\n  }\n  \n  self.req.on('error', self.clientErrorHandler)\n  self.req.on('drain', function() {\n    self.emit('drain')\n  })\n  self.on('end', function() {\n    if ( self.req.connection ) self.req.connection.removeListener('error', self._parserErrorHandler)\n  })\n  self.emit('request', self.req)\n}\n\nRequest.prototype.abort = function () {\n  this._aborted = true\n  \n  if (this.req) {\n    this.req.abort()\n  }\n  else if (this.response) {\n    this.response.abort()\n  }\n  \n  this.emit(\"abort\")\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var response = this.response\n  // Called after the response is received\n  if (dest.headers) {\n    dest.headers['content-type'] = response.headers['content-type']\n    if (response.headers['content-length']) {\n      dest.headers['content-length'] = response.headers['content-length']\n    }\n  }\n  if (dest.setHeader) {\n    for (var i in response.headers) {\n      dest.setHeader(i, response.headers[i])\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (this.pipefilter) this.pipefilter(response, dest)\n}\n\n// Composable API\nRequest.prototype.setHeader = function (name, value, clobber) {\n  if (clobber === undefined) clobber = true\n  if (clobber || !this.headers.hasOwnProperty(name)) this.headers[name] = value\n  else this.headers[name] += ',' + value\n  return this\n}\nRequest.prototype.setHeaders = function (headers) {\n  for (var i in headers) {this.setHeader(i, headers[i])}\n  return this\n}\nRequest.prototype.qs = function (q, clobber) {\n  var base\n  if (!clobber && this.uri.query) base = qs.parse(this.uri.query)\n  else base = {}\n  \n  for (var i in q) {\n    base[i] = q[i]\n  }\n  \n  this.uri = url.parse(this.uri.href.split('?')[0] + '?' + qs.stringify(base))\n  this.url = this.uri\n  \n  return this\n}\nRequest.prototype.form = function (form) {\n  if (form) {\n    this.headers['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n    this.body = qs.stringify(form).toString('utf8')\n    return this\n  } \n  // create form-data object\n  this._form = new FormData()\n  return this._form\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n  self.body = []\n\n  if (!self.headers['content-type']) {\n    self.headers['content-type'] = 'multipart/related; boundary=' + self.boundary\n  } else {\n    self.headers['content-type'] = self.headers['content-type'].split(';')[0] + '; boundary=' + self.boundary\n  }\n\n  if (!multipart.forEach) throw new Error('Argument error, options.multipart.')\n\n  if (self.preambleCRLF) {\n    self.body.push(new Buffer('\\r\\n'))\n  }\n  \n  multipart.forEach(function (part) {\n    var body = part.body\n    if(body == null) throw Error('Body attribute missing in multipart.')\n    delete part.body\n    var preamble = '--' + self.boundary + '\\r\\n'\n    Object.keys(part).forEach(function (key) {\n      preamble += key + ': ' + part[key] + '\\r\\n'\n    })\n    preamble += '\\r\\n'\n    self.body.push(new Buffer(preamble))\n    self.body.push(new Buffer(body))\n    self.body.push(new Buffer('\\r\\n'))\n  })\n  self.body.push(new Buffer('--' + self.boundary + '--'))\n  return self\n}\nRequest.prototype.json = function (val) {\n  this.setHeader('accept', 'application/json')\n  this._json = true\n  if (typeof val === 'boolean') {\n    if (typeof this.body === 'object') {\n      this.setHeader('content-type', 'application/json')\n      this.body = JSON.stringify(this.body)\n    }\n  } else {\n    this.setHeader('content-type', 'application/json')\n    this.body = JSON.stringify(val)\n  }\n  return this\n}\nfunction getHeader(name, headers) {\n    var result, re, match\n    Object.keys(headers).forEach(function (key) {\n        re = new RegExp(name, 'i')\n        match = key.match(re)\n        if (match) result = headers[key]\n    })\n    return result\n}\nRequest.prototype.aws = function (opts, now) {\n  if (!now) {\n    this._aws = opts\n    return this\n  }\n  var date = new Date()\n  this.setHeader('date', date.toUTCString())\n  var auth =\n    { key: opts.key\n    , secret: opts.secret\n    , verb: this.method.toUpperCase()\n    , date: date\n    , contentType: getHeader('content-type', this.headers) || ''\n    , md5: getHeader('content-md5', this.headers) || ''\n    , amazonHeaders: aws.canonicalizeHeaders(this.headers)\n    }\n  if (opts.bucket && this.path) {\n    auth.resource = '/' + opts.bucket + this.path\n  } else if (opts.bucket && !this.path) {\n    auth.resource = '/' + opts.bucket\n  } else if (!opts.bucket && this.path) {\n    auth.resource = this.path\n  } else if (!opts.bucket && !this.path) {\n    auth.resource = '/'\n  }\n  auth.resource = aws.canonicalizeResource(auth.resource)\n  this.setHeader('authorization', aws.authorization(auth))\n  \n  return this\n}\n\nRequest.prototype.oauth = function (_oauth) {\n  var form\n  if (this.headers['content-type'] && \n      this.headers['content-type'].slice(0, 'application/x-www-form-urlencoded'.length) ===\n        'application/x-www-form-urlencoded' \n     ) {\n    form = qs.parse(this.body)\n  }\n  if (this.uri.query) {\n    form = qs.parse(this.uri.query)\n  } \n  if (!form) form = {}\n  var oa = {}\n  for (var i in form) oa[i] = form[i]\n  for (var i in _oauth) oa['oauth_'+i] = _oauth[i]\n  if (!oa.oauth_version) oa.oauth_version = '1.0'\n  if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( (new Date()).getTime() / 1000 ).toString()\n  if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '')\n  \n  oa.oauth_signature_method = 'HMAC-SHA1'\n  \n  var consumer_secret = oa.oauth_consumer_secret\n  delete oa.oauth_consumer_secret\n  var token_secret = oa.oauth_token_secret\n  delete oa.oauth_token_secret\n  \n  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname\n  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret)\n  \n  // oa.oauth_signature = signature\n  for (var i in form) {\n    if ( i.slice(0, 'oauth_') in _oauth) {\n      // skip \n    } else {\n      delete oa['oauth_'+i]\n      if (i !== 'x_auth_mode') delete oa[i]\n    }\n  }\n  this.headers.Authorization = \n    'OAuth '+Object.keys(oa).sort().map(function (i) {return i+'=\"'+oauth.rfc3986(oa[i])+'\"'}).join(',')\n  this.headers.Authorization += ',oauth_signature=\"' + oauth.rfc3986(signature) + '\"'\n  return this\n}\nRequest.prototype.jar = function (jar) {\n  var cookies\n  \n  if (this._redirectsFollowed === 0) {\n    this.originalCookieHeader = this.headers.cookie\n  }\n  \n  if (jar === false) {\n    // disable cookies\n    cookies = false\n    this._disableCookies = true\n  } else if (jar) {\n    // fetch cookie from the user defined cookie jar\n    cookies = jar.get({ url: this.uri.href })\n  } else {\n    // fetch cookie from the global cookie jar\n    cookies = cookieJar.get({ url: this.uri.href })\n  }\n  \n  if (cookies && cookies.length) {\n    var cookieString = cookies.map(function (c) {\n      return c.name + \"=\" + c.value\n    }).join(\"; \")\n\n    if (this.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      this.headers.cookie = this.originalCookieHeader + '; ' + cookieString\n    } else {\n      this.headers.cookie = cookieString\n    }\n  }\n  this._jar = jar\n  return this\n}\n\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  if (this.response) {\n    if (this._destdata) {\n      throw new Error(\"You cannot pipe after data has been emitted from the response.\")\n    } else if (this._ended) {\n      throw new Error(\"You cannot pipe after the response has been ended.\")\n    } else {\n      stream.Stream.prototype.pipe.call(this, dest, opts)\n      this.pipeDest(dest)\n      return dest\n    }\n  } else {\n    this.dests.push(dest)\n    stream.Stream.prototype.pipe.call(this, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  if (!this._started) this.start()\n  return this.req.write.apply(this.req, arguments)\n}\nRequest.prototype.end = function (chunk) {\n  if (chunk) this.write(chunk)\n  if (!this._started) this.start()\n  this.req.end()\n}\nRequest.prototype.pause = function () {\n  if (!this.response) this._paused = true\n  else this.response.pause.apply(this.response, arguments)\n}\nRequest.prototype.resume = function () {\n  if (!this.response) this._paused = false\n  else this.response.resume.apply(this.response, arguments)\n}\nRequest.prototype.destroy = function () {\n  if (!this._ended) this.end()\n}\n\n// organize params for post, put, head, del\nfunction initParams(uri, options, callback) {\n  if ((typeof options === 'function') && !callback) callback = options\n  if (options && typeof options === 'object') {\n    options.uri = uri\n  } else if (typeof uri === 'string') {\n    options = {uri:uri}\n  } else {\n    options = uri\n    uri = options.uri\n  }\n  return { uri: uri, options: options, callback: callback }\n}\n\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') throw new Error('undefined is not a valid uri or options object.')\n  if ((typeof options === 'function') && !callback) callback = options\n  if (options && typeof options === 'object') {\n    options.uri = uri\n  } else if (typeof uri === 'string') {\n    options = {uri:uri}\n  } else {\n    options = uri\n  }\n\n  if (callback) options.callback = callback\n  var r = new Request(options)\n  return r\n}\n\nmodule.exports = request\n\nrequest.initParams = initParams\n\nrequest.defaults = function (options, requester) {\n  var def = function (method) {\n    var d = function (uri, opts, callback) {\n      var params = initParams(uri, opts, callback)\n      for (var i in options) {\n        if (params.options[i] === undefined) params.options[i] = options[i]\n      }\n      if(typeof requester === 'function') {\n        if(method === request) {\n          method = requester\n        } else {\n          params.options._requester = requester\n        }\n      }\n      return method(params.options, params.callback)\n    }\n    return d\n  }\n  var de = def(request)\n  de.get = def(request.get)\n  de.post = def(request.post)\n  de.put = def(request.put)\n  de.head = def(request.head)\n  de.del = def(request.del)\n  de.cookie = def(request.cookie)\n  de.jar = request.jar\n  return de\n}\n\nrequest.forever = function (agentOptions, optionsArg) {\n  var options = {}\n  if (optionsArg) {\n    for (option in optionsArg) {\n      options[option] = optionsArg[option]\n    }\n  }\n  if (agentOptions) options.agentOptions = agentOptions\n  options.forever = true\n  return request.defaults(options)\n}\n\nrequest.get = request\nrequest.post = function (uri, options, callback) {\n  var params = initParams(uri, options, callback)\n  params.options.method = 'POST'\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.put = function (uri, options, callback) {\n  var params = initParams(uri, options, callback)\n  params.options.method = 'PUT'\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.head = function (uri, options, callback) {\n  var params = initParams(uri, options, callback)\n  params.options.method = 'HEAD'\n  if (params.options.body || \n      params.options.requestBodyStream || \n      (params.options.json && typeof params.options.json !== 'boolean') || \n      params.options.multipart) {\n    throw new Error(\"HTTP HEAD requests MUST NOT include a request body.\")\n  }\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.del = function (uri, options, callback) {\n  var params = initParams(uri, options, callback)\n  params.options.method = 'DELETE'\n  if(typeof params.options._requester === 'function') {\n    request = params.options._requester\n  }\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.jar = function () {\n  return new CookieJar\n}\nrequest.cookie = function (str) {\n  if (str && str.uri) str = str.uri\n  if (typeof str !== 'string') throw new Error(\"The cookie function only accepts STRING as param\")\n  return new Cookie(str)\n}\n\n// Safe toJSON\n\nfunction getSafe (self, uuid) {  \n  if (typeof self === 'object' || typeof self === 'function') var safe = {}\n  if (Array.isArray(self)) var safe = []\n\n  var recurse = []\n  \n  Object.defineProperty(self, uuid, {})\n  \n  var attrs = Object.keys(self).filter(function (i) {\n    if (i === uuid) return false \n    if ( (typeof self[i] !== 'object' && typeof self[i] !== 'function') || self[i] === null) return true\n    return !(Object.getOwnPropertyDescriptor(self[i], uuid))\n  })\n  \n  \n  for (var i=0;i<attrs.length;i++) {\n    if ( (typeof self[attrs[i]] !== 'object' && typeof self[attrs[i]] !== 'function') || \n          self[attrs[i]] === null\n        ) {\n      safe[attrs[i]] = self[attrs[i]]\n    } else {\n      recurse.push(attrs[i])\n      Object.defineProperty(self[attrs[i]], uuid, {})\n    }\n  }\n\n  for (var i=0;i<recurse.length;i++) {\n    safe[recurse[i]] = getSafe(self[recurse[i]], uuid)\n  }\n  \n  return safe\n}\n\nfunction toJSON () {\n  return getSafe(this, (((1+Math.random())*0x10000)|0).toString(16))\n}\n\nRequest.prototype.toJSON = toJSON\n\n"]],"start1":0,"start2":0,"length1":0,"length2":33675}]],"length":33675}
