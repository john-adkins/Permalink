{"ts":1353251147501,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Connection = require('./connection').Connection,\n  ReadPreference = require('./read_preference').ReadPreference,\n  DbCommand = require('../commands/db_command').DbCommand,\n  MongoReply = require('../responses/mongo_reply').MongoReply,\n  ConnectionPool = require('./connection_pool').ConnectionPool,\n  EventEmitter = require('events').EventEmitter,\n  inherits = require('util').inherits;\n\n/**\n * Class representing a single MongoDB Server connection\n *\n * Options\n *  - **readPreference** {String, default:null}, set's the read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST)\n *  - **ssl** {Boolean, default:false}, use ssl connection (needs to have a mongod server with ssl support)\n *  - **slaveOk** {Boolean, default:false}, legacy option allowing reads from secondary, use **readPrefrence** instead.\n *  - **poolSize** {Number, default:1}, number of connections in the connection pool, set to 1 as default for legacy reasons.\n *  - **socketOptions** {Object, default:null}, an object containing socket options to use (noDelay:(boolean), keepAlive:(number), connectTimeoutMS:(number), socketTimeoutMS:(number))\n *  - **logger** {Object, default:null}, an object representing a logger that you want to use, needs to support functions debug, log, error **({error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}})**.\n *  - **auto_reconnect** {Boolean, default:false}, reconnect on error.\n *  - **disableDriverBSONSizeCheck** {Boolean, default:false}, force the server to error if the BSON message is to big\n *\n * @class Represents a Server connection.\n * @param {String} host the server host\n * @param {Number} port the server port\n * @param {Object} [options] optional options for insert command\n */\nfunction Server(host, port, options) {\n  // Set up event emitter\n  EventEmitter.call(this);\n  // Set up Server instance\n  if(!(this instanceof Server)) return new Server(host, port, options);\n  // Ensure correct values\n  if(port != null && typeof port == 'object') {\n    options = port;\n    port = Connection.DEFAULT_PORT;\n  }\n\n  var self = this;\n  this.host = host;\n  this.port = port;\n  this.options = options == null ? {} : options;\n  this.internalConnection;\n  this.internalMaster = false;\n  this.connected = false;\n  this.poolSize = this.options.poolSize == null ? 5 : this.options.poolSize;\n  this.disableDriverBSONSizeCheck = this.options.disableDriverBSONSizeCheck != null ? this.options.disableDriverBSONSizeCheck : false;\n  this.ssl = this.options.ssl == null ? false : this.options.ssl;\n  this.slaveOk = this.options[\"slave_ok\"];\n  this._used = false;\n\n  // Get the readPreference\n  var readPreference = this.options['readPreference'];\n  // Read preference setting\n  if(readPreference != null) {\n    if(readPreference != ReadPreference.PRIMARY && readPreference != ReadPreference.SECONDARY && readPreference != ReadPreference.NEAREST\n      && readPreference != ReadPreference.SECONDARY_PREFERRED && readPreference != ReadPreference.PRIMARY_PREFERRED) {\n        throw new Error(\"Illegal readPreference mode specified, \" + readPreference);\n    }\n\n    // Set read Preference\n    this._readPreference = readPreference;\n  } else {\n    this._readPreference = null;\n  }\n\n  // Contains the isMaster information returned from the server\n  this.isMasterDoc;\n\n  // Set default connection pool options\n  this.socketOptions = this.options.socketOptions != null ? this.options.socketOptions : {};\n  if(this.disableDriverBSONSizeCheck) this.socketOptions.disableDriverBSONSizeCheck = this.disableDriverBSONSizeCheck;\n  // Set ssl up if it's defined\n  if(this.ssl) {\n    this.socketOptions.ssl = true;\n  }\n\n  // Set up logger if any set\n  this.logger = this.options.logger != null\n    && (typeof this.options.logger.debug == 'function')\n    && (typeof this.options.logger.error == 'function')\n    && (typeof this.options.logger.log == 'function')\n      ? this.options.logger : {error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}};\n\n  // Just keeps list of events we allow\n  this.eventHandlers = {error:[], parseError:[], poolReady:[], message:[], close:[], timeout:[]};\n  // Internal state of server connection\n  this._serverState = 'disconnected';\n  // this._timeout = false;\n  // Contains state information about server connection\n  this._state = {'runtimeStats': {'queryStats':new RunningStats()}};\n  // Do we record server stats or not\n  this.recordQueryStats = false;\n};\n\n/**\n * @ignore\n */\n// Inherit simple event emitter\ninherits(Server, EventEmitter);\n\n//\n//  Deprecated, USE ReadPreferences class\n//\nServer.READ_PRIMARY = ReadPreference.PRIMARY;\nServer.READ_SECONDARY = ReadPreference.SECONDARY_PREFERRED;\nServer.READ_SECONDARY_ONLY = ReadPreference.SECONDARY;\n\n/**\n * Always ourselves\n * @ignore\n */\nServer.prototype.setReadPreference = function() {}\n\n/**\n * @ignore\n */\nServer.prototype.isMongos = function() {\n  return this.isMasterDoc != null && this.isMasterDoc['msg'] == \"isdbgrid\" ? true : false;\n}\n\n/**\n * @ignore\n */\nServer.prototype._isUsed = function() {\n  return this._used;\n}\n\n/**\n * @ignore\n */\nServer.prototype.close = function(callback) {\n  // Remove all local listeners\n  this.removeAllListeners();\n\n  if(this.connectionPool != null) {\n    // Remove all the listeners on the pool so it does not fire messages all over the place\n    this.connectionPool.removeAllEventListeners();\n    // Close the connection if it's open\n    this.connectionPool.stop(true);\n  }\n\n  // Set server status as disconnected\n  this._serverState = 'disconnected';\n  // Peform callback if present\n  if(typeof callback === 'function') callback();\n};\n\n/**\n * @ignore\n */\nServer.prototype.isConnected = function() {\n  return this._serverState == 'connected';\n}\n\n/**\n * @ignore\n */\nServer.prototype.allServerInstances = function() {\n  return [this];\n}\n\n/**\n * @ignore\n */\nServer.prototype.isSetMember = function() {\n  return this['replicasetInstance'] != null || this['mongosInstance'] != null;\n}\n\n/**\n * @ignore\n */\nServer.prototype.connect = function(dbInstance, options, callback) {\n  if('function' === typeof options) callback = options, options = {};\n  if(options == null) options = {};\n  if(!('function' === typeof callback)) callback = null;\n\n  // Currently needed to work around problems with multiple connections in a pool with ssl\n  // TODO fix if possible\n  if(this.ssl == true) {\n    // Set up socket options for ssl\n    this.socketOptions.ssl = true;\n  }\n\n  // Let's connect\n  var server = this;\n  // Let's us override the main receiver of events\n  var eventReceiver = options.eventReceiver != null ? options.eventReceiver : this;\n  // Creating dbInstance\n  this.dbInstance = dbInstance;\n  // Save reference to dbInstance\n  this.dbInstances = [dbInstance];\n\n  // Force connection pool if there is one\n  if(server.connectionPool) server.connectionPool.stop();\n\n  // Set server state to connecting\n  this._serverState = 'connecting';\n  // Ensure dbInstance can do a slave query if it's set\n  dbInstance.slaveOk = this.slaveOk ? this.slaveOk : dbInstance.slaveOk;\n  // Create connection Pool instance with the current BSON serializer\n  var connectionPool = new ConnectionPool(this.host, this.port, this.poolSize, dbInstance.bson,  this.socketOptions);\n  // Set logger on pool\n  connectionPool.logger = this.logger;\n\n  // Set up a new pool using default settings\n  server.connectionPool = connectionPool;\n\n  // Set basic parameters passed in\n  var returnIsMasterResults = options.returnIsMasterResults == null ? false : options.returnIsMasterResults;\n\n  // Create a default connect handler, overriden when using replicasets\n  var connectCallback = function(err, reply) {\n    // ensure no callbacks get called twice\n    var internalCallback = callback;\n    callback = null;\n    // If something close down the connection and removed the callback before\n    // proxy killed connection etc, ignore the erorr as close event was isssued\n    if(err != null && internalCallback == null) return;\n    // Internal callback\n    if(err != null) return internalCallback(err, null);\n    server.master = reply.documents[0].ismaster == 1 ? true : false;\n    server.connectionPool.setMaxBsonSize(reply.documents[0].maxBsonObjectSize);\n    // Set server as connected\n    server.connected = true;\n    // Save document returned so we can query it\n    server.isMasterDoc = reply.documents[0];\n\n    // Emit open event\n    _emitAcrossAllDbInstances(server, eventReceiver, \"open\", null, returnIsMasterResults ? reply : dbInstance, null);\n\n    // If we have it set to returnIsMasterResults\n    if(returnIsMasterResults) {\n      internalCallback(null, reply, server);\n    } else {\n      internalCallback(null, dbInstance, server);\n    }\n  };\n\n  // Let's us override the main connect callback\n  var connectHandler = options.connectHandler == null ? connectCallback : options.connectHandler;\n\n  // Set up on connect method\n  connectionPool.on(\"poolReady\", function() {\n    // Create db command and Add the callback to the list of callbacks by the request id (mapping outgoing messages to correct callbacks)\n    var db_command = DbCommand.NcreateIsMasterCommand(dbInstance, dbInstance.databaseName);\n    // Check out a reader from the pool\n    var connection = connectionPool.checkoutConnection();\n    // Set server state to connEcted\n    server._serverState = 'connected';\n\n    // Register handler for messages\n    dbInstance._registerHandler(db_command, false, connection, connectHandler);\n\n    // Write the command out\n    connection.write(db_command);\n  })\n\n  // Set up item connection\n  connectionPool.on(\"message\", function(message) {\n    // Attempt to parse the message\n    try {\n      // Create a new mongo reply\n      var mongoReply = new MongoReply()\n      // Parse the header\n      mongoReply.parseHeader(message, connectionPool.bson)\n      // If message size is not the same as the buffer size\n      // something went terribly wrong somewhere\n      if(mongoReply.messageLength != message.length) {\n        // Emit the error\n        if(eventReceiver.listeners(\"error\") && eventReceiver.listeners(\"error\").length > 0) eventReceiver.emit(\"error\", new Error(\"bson length is different from message length\"), server);\n        // Remove all listeners\n        server.removeAllListeners();\n      } else {\n        var startDate = new Date().getTime();\n\n        // Callback instance\n        var callbackInfo = null;\n        var dbInstanceObject = null;\n\n        // Locate a callback instance and remove any additional ones\n        for(var i = 0; i < server.dbInstances.length; i++) {\n          var dbInstanceObjectTemp = server.dbInstances[i];\n          var hasHandler = dbInstanceObjectTemp._hasHandler(mongoReply.responseTo.toString());\n          // Assign the first one we find and remove any duplicate ones\n          if(hasHandler && callbackInfo == null) {\n            callbackInfo = dbInstanceObjectTemp._findHandler(mongoReply.responseTo.toString());\n            dbInstanceObject = dbInstanceObjectTemp;\n          } else if(hasHandler) {\n            dbInstanceObjectTemp._removeHandler(mongoReply.responseTo.toString());\n          }\n        }\n\n        // The command executed another request, log the handler again under that request id\n        if(mongoReply.requestId > 0 && mongoReply.cursorId.toString() != \"0\" && callbackInfo.info && callbackInfo.info.exhaust) {\n          dbInstance._reRegisterHandler(mongoReply.requestId, callbackInfo);\n        }\n\n        // Only execute callback if we have a caller\n        // chained is for findAndModify as it does not respect write concerns\n        if(callbackInfo && callbackInfo.callback && callbackInfo.info && Array.isArray(callbackInfo.info.chained)) {\n          // Check if callback has already been fired (missing chain command)\n          var chained = callbackInfo.info.chained;\n          var numberOfFoundCallbacks = 0;\n          for(var i = 0; i < chained.length; i++) {\n            if(dbInstanceObject._hasHandler(chained[i])) numberOfFoundCallbacks++;\n          }\n\n          // If we have already fired then clean up rest of chain and move on\n          if(numberOfFoundCallbacks != chained.length) {\n            for(var i = 0; i < chained.length; i++) {\n              dbInstanceObject._removeHandler(chained[i]);\n            }\n\n            // Just return from function\n            return;\n          }\n\n          // Parse the body\n          mongoReply.parseBody(message, connectionPool.bson, callbackInfo.info.raw, function(err) {\n            if(err != null) {\n              // If pool connection is already closed\n              if(server._serverState === 'disconnected') return;\n              // Set server state to disconnected\n              server._serverState = 'disconnected';\n              // Remove all listeners and close the connection pool\n              server.removeAllListeners();\n              connectionPool.stop(true);\n\n              // If we have a callback return the error\n              if(typeof callback === 'function') {\n                // ensure no callbacks get called twice\n                var internalCallback = callback;\n                callback = null;\n                // Perform callback\n                internalCallback(new Error(\"connection closed due to parseError\"), null, server);\n              } else if(server.isSetMember()) {\n                if(server.listeners(\"parseError\") && server.listeners(\"parseError\").length > 0) server.emit(\"parseError\", new Error(\"connection closed due to parseError\"), server);\n              } else {\n                if(eventReceiver.listeners(\"parseError\") && eventReceiver.listeners(\"parseError\").length > 0) eventReceiver.emit(\"parseError\", new Error(\"connection closed due to parseError\"), server);\n              }\n\n              // If we are a single server connection fire errors correctly\n              if(!server.isSetMember()) {\n                // Fire all callback errors\n                _fireCallbackErrors(server, new Error(\"connection closed due to parseError\"));\n                // Emit error\n                _emitAcrossAllDbInstances(server, eventReceiver, \"parseError\", server, null, true);\n              }\n              // Short cut\n              return;\n            }\n\n            // Fetch the callback\n            var callbackInfo = dbInstanceObject._findHandler(mongoReply.responseTo.toString());\n            // If we have an error let's execute the callback and clean up all other\n            // chained commands\n            var firstResult = mongoReply && mongoReply.documents;\n            // Check for an error, if we have one let's trigger the callback and clean up\n            // The chained callbacks\n            if(firstResult[0].err != null || firstResult[0].errmsg != null) {\n              // Trigger the callback for the error\n              dbInstanceObject._callHandler(mongoReply.responseTo, mongoReply, null);\n            } else {\n              var chainedIds = callbackInfo.info.chained;\n\n              if(chainedIds.length > 0 && chainedIds[chainedIds.length - 1] == mongoReply.responseTo) {\n                // Cleanup all other chained calls\n                chainedIds.pop();\n                // Remove listeners\n                for(var i = 0; i < chainedIds.length; i++) dbInstanceObject._removeHandler(chainedIds[i]);\n                // Call the handler\n                dbInstanceObject._callHandler(mongoReply.responseTo, callbackInfo.info.results.shift(), null);\n              } else{\n                // Add the results to all the results\n                for(var i = 0; i < chainedIds.length; i++) {\n                  var handler = dbInstanceObject._findHandler(chainedIds[i]);\n                  // Check if we have an object, if it's the case take the current object commands and\n                  // and add this one\n                  if(handler.info != null) {\n                    handler.info.results = Array.isArray(callbackInfo.info.results) ? callbackInfo.info.results : [];\n                    handler.info.results.push(mongoReply);\n                  }\n                }\n              }\n            }\n          });\n        } else if(callbackInfo && callbackInfo.callback && callbackInfo.info) {\n          // Parse the body\n          mongoReply.parseBody(message, connectionPool.bson, callbackInfo.info.raw, function(err) {\n            if(err != null) {\n              // If pool connection is already closed\n              if(server._serverState === 'disconnected') return;\n              // Set server state to disconnected\n              server._serverState = 'disconnected';\n              // Remove all listeners and close the connection pool\n              server.removeAllListeners();\n              connectionPool.stop(true);\n\n              // If we have a callback return the error\n              if(typeof callback === 'function') {\n                // ensure no callbacks get called twice\n                var internalCallback = callback;\n                callback = null;\n                // Perform callback\n                internalCallback(new Error(\"connection closed due to parseError\"), null, server);\n              } else if(server.isSetMember()) {\n                if(server.listeners(\"parseError\") && server.listeners(\"parseError\").length > 0) server.emit(\"parseError\", new Error(\"connection closed due to parseError\"), server);\n              } else {\n                if(eventReceiver.listeners(\"parseError\") && eventReceiver.listeners(\"parseError\").length > 0) eventReceiver.emit(\"parseError\", new Error(\"connection closed due to parseError\"), server);\n              }\n\n              // If we are a single server connection fire errors correctly\n              if(!server.isSetMember()) {\n                // Fire all callback errors\n                _fireCallbackErrors(server, new Error(\"connection closed due to parseError\"));\n                // Emit error\n                _emitAcrossAllDbInstances(server, eventReceiver, \"parseError\", server, null, true);\n              }\n              // Short cut\n              return;\n            }\n\n            // Let's record the stats info if it's enabled\n            if(server.recordQueryStats == true && server._state['runtimeStats'] != null\n              && server._state.runtimeStats['queryStats'] instanceof RunningStats) {\n              // Add data point to the running statistics object\n              server._state.runtimeStats.queryStats.push(new Date().getTime() - callbackInfo.info.start);\n            }\n\n            dbInstanceObject._callHandler(mongoReply.responseTo, mongoReply, null);\n          });\n        }\n      }\n    } catch (err) {\n      // Throw error in next tick\n      process.nextTick(function() {\n        throw err;\n      })\n    }\n  });\n\n  // Handle timeout\n  connectionPool.on(\"timeout\", function(err) {\n    // If pool connection is already closed\n    if(server._serverState === 'disconnected') return;\n    // Set server state to disconnected\n    server._serverState = 'disconnected';\n    // If we have a callback return the error\n    if(typeof callback === 'function') {\n      // ensure no callbacks get called twice\n      var internalCallback = callback;\n      callback = null;\n      // Perform callback\n      internalCallback(err, null, server);\n    } else if(server.isSetMember()) {\n      if(server.listeners(\"timeout\") && server.listeners(\"timeout\").length > 0) server.emit(\"timeout\", err, server);\n    } else {\n      if(eventReceiver.listeners(\"timeout\") && eventReceiver.listeners(\"timeout\").length > 0) eventReceiver.emit(\"timeout\", err, server);\n    }\n\n    // If we are a single server connection fire errors correctly\n    if(!server.isSetMember()) {\n      // Fire all callback errors\n      _fireCallbackErrors(server, err);\n      // Emit error\n      _emitAcrossAllDbInstances(server, eventReceiver, \"timeout\", err, server, true);\n    }\n  });\n\n  // Handle errors\n  connectionPool.on(\"error\", function(message) {\n    // If pool connection is already closed\n    if(server._serverState === 'disconnected') return;\n    // Set server state to disconnected\n    server._serverState = 'disconnected';\n    // If we have a callback return the error\n    if(typeof callback === 'function') {\n      // ensure no callbacks get called twice\n      var internalCallback = callback;\n      callback = null;\n      // Perform callback\n      internalCallback(new Error(message && message.err ? message.err : message), null, server);\n    } else if(server.isSetMember()) {\n      if(server.listeners(\"error\") && server.listeners(\"error\").length > 0) server.emit(\"error\", new Error(message && message.err ? message.err : message), server);\n    } else {\n      if(eventReceiver.listeners(\"error\") && eventReceiver.listeners(\"error\").length > 0) eventReceiver.emit(\"error\", new Error(message && message.err ? message.err : message), server);\n    }\n\n    // If we are a single server connection fire errors correctly\n    if(!server.isSetMember()) {\n      // Fire all callback errors\n      _fireCallbackErrors(server, new Error(message && message.err ? message.err : message));\n      // Emit error\n      _emitAcrossAllDbInstances(server, eventReceiver, \"error\", new Error(message && message.err ? message.err : message), server, true);\n    }\n  });\n\n  // Handle close events\n  connectionPool.on(\"close\", function() {\n    // If pool connection is already closed\n    if(server._serverState === 'disconnected') return;\n    // Set server state to disconnected\n    server._serverState = 'disconnected';\n    // If we have a callback return the error\n    if(typeof callback == 'function') {\n      // ensure no callbacks get called twice\n      var internalCallback = callback;\n      callback = null;\n      // Perform callback\n      internalCallback(new Error(\"connection closed\"), null, server);\n    } else if(server.isSetMember()) {\n      if(server.listeners(\"close\") && server.listeners(\"close\").length > 0) server.emit(\"close\", new Error(\"connection closed\"), server);\n    } else {\n      if(eventReceiver.listeners(\"close\") && eventReceiver.listeners(\"close\").length > 0) eventReceiver.emit(\"close\", new Error(\"connection closed\"), server);\n    }\n\n    // If we are a single server connection fire errors correctly\n    if(!server.isSetMember()) {\n      // Fire all callback errors\n      _fireCallbackErrors(server, new Error(\"connection closed\"));\n      // Emit error\n      _emitAcrossAllDbInstances(server, eventReceiver, \"close\", server, null, true);\n    }\n  });\n\n  // If we have a parser error we are in an unknown state, close everything and emit\n  // error\n  connectionPool.on(\"parseError\", function(message) {\n    // If pool connection is already closed\n    if(server._serverState === 'disconnected') return;\n    // Set server state to disconnected\n    server._serverState = 'disconnected';\n    // If we have a callback return the error\n    if(typeof callback === 'function') {\n      // ensure no callbacks get called twice\n      var internalCallback = callback;\n      callback = null;\n      // Perform callback\n      internalCallback(new Error(\"connection closed due to parseError\"), null, server);\n    } else if(server.isSetMember()) {\n      if(server.listeners(\"parseError\") && server.listeners(\"parseError\").length > 0) server.emit(\"parseError\", new Error(\"connection closed due to parseError\"), server);\n    } else {\n      if(eventReceiver.listeners(\"parseError\") && eventReceiver.listeners(\"parseError\").length > 0) eventReceiver.emit(\"parseError\", new Error(\"connection closed due to parseError\"), server);\n    }\n\n    // If we are a single server connection fire errors correctly\n    if(!server.isSetMember()) {\n      // Fire all callback errors\n      _fireCallbackErrors(server, new Error(\"connection closed due to parseError\"));\n      // Emit error\n      _emitAcrossAllDbInstances(server, eventReceiver, \"parseError\", server, null, true);\n    }\n  });\n\n  // Boot up connection poole, pass in a locator of callbacks\n  connectionPool.start();\n}\n\n/**\n * Fire all the errors\n * @ignore\n */\nvar _fireCallbackErrors = function(server, err) {\n  // Locate all the possible callbacks that need to return\n  for(var i = 0; i < server.dbInstances.length; i++) {\n    // Fetch the db Instance\n    var dbInstance = server.dbInstances[i];\n    // Check all callbacks\n    var keys = Object.keys(dbInstance._callBackStore._notReplied);\n    // For each key check if it's a callback that needs to be returned\n    for(var j = 0; j < keys.length; j++) {\n      var info = dbInstance._callBackStore._notReplied[keys[j]];\n      // Check if we have a chained command (findAndModify)\n      if(info && info['chained'] && Array.isArray(info['chained']) && info['chained'].length > 0) {\n        var chained = info['chained'];\n        // Only callback once and the last one is the right one\n        var finalCallback = chained.pop();\n        if(info.connection.socketOptions.host === server.host && info.connection.socketOptions.port === server.port) {\n          dbInstance._callBackStore.emit(finalCallback, err, null);\n        }\n\n        // Put back the final callback to ensure we don't call all commands in the chain\n        chained.push(finalCallback);\n\n        // Remove all chained callbacks\n        for(var i = 0; i < chained.length; i++) {\n          delete dbInstance._callBackStore._notReplied[chained[i]];\n        }\n      } else {\n        if(info && info.connection.socketOptions.host === server.host && info.connection.socketOptions.port === server.port) {\n          dbInstance._callBackStore.emit(keys[j], err, null);\n        }\n      }\n    }\n  }\n}\n\n/**\n * @ignore\n */\nvar _emitAcrossAllDbInstances = function(server, filterDb, event, message, object, resetConnection) {\n  // Emit close event across all db instances sharing the sockets\n  var allServerInstances = server.allServerInstances();\n  // Fetch the first server instance\n  var serverInstance = allServerInstances[0];\n  // For all db instances signal all db instances\n  if(Array.isArray(serverInstance.dbInstances) && serverInstance.dbInstances.length >= 1) {\n\t  for(var i = 0; i < serverInstance.dbInstances.length; i++) {\n      var dbInstance = serverInstance.dbInstances[i];\n      // Set the parent\n      if(resetConnection && typeof dbInstance.openCalled != 'undefined')\n        dbInstance.openCalled = false;\n      // Check if it's our current db instance and skip if it is\n      if(filterDb == null || filterDb.databaseName !== dbInstance.databaseName || filterDb.tag !== dbInstance.tag) {\n        // Only emit if there is a listener\n        if(dbInstance.listeners(event).length > 0)\n  \t     dbInstance.emit(event, message, object);\n      }\n    }\n  }\n}\n\n/**\n * @ignore\n */\nServer.prototype.allRawConnections = function() {\n  return this.connectionPool.getAllConnections();\n}\n\n/**\n * Check if a writer can be provided\n * @ignore\n */\nvar canCheckoutWriter = function(self, read) {\n  // We cannot write to an arbiter or secondary server\n  if(self.isMasterDoc['arbiterOnly'] == true) {\n    return new Error(\"Cannot write to an arbiter\");\n  } if(self.isMasterDoc['secondary'] == true) {\n    return new Error(\"Cannot write to a secondary\");\n  } else if(read == true && self._readPreference == ReadPreference.SECONDARY && self.isMasterDoc['ismaster'] == true) {\n    return new Error(\"Cannot read from primary when secondary only specified\");\n  }\n\n  // Return no error\n  return null;\n}\n\n/**\n * @ignore\n */\nServer.prototype.checkoutWriter = function(read) {\n  if(read == true) return this.connectionPool.checkoutConnection();\n  // Check if are allowed to do a checkout (if we try to use an arbiter f.ex)\n  var result = canCheckoutWriter(this, read);\n  // If the result is null check out a writer\n  if(result == null && this.connectionPool != null) {\n    return this.connectionPool.checkoutConnection();\n  } else if(result == null) {\n    return null;\n  } else {\n    return result;\n  }\n}\n\n/**\n * Check if a reader can be provided\n * @ignore\n */\nvar canCheckoutReader = function(self) {\n  // We cannot write to an arbiter or secondary server\n  if(self.isMasterDoc && self.isMasterDoc['arbiterOnly'] == true) {\n    return new Error(\"Cannot write to an arbiter\");\n  } else if(self._readPreference != null) {\n    // If the read preference is Primary and the instance is not a master return an error\n    if((self._readPreference == ReadPreference.PRIMARY) && self.isMasterDoc['ismaster'] != true) {\n      return new Error(\"Read preference is Server.PRIMARY and server is not master\");\n    } else if(self._readPreference == ReadPreference.SECONDARY && self.isMasterDoc['ismaster'] == true) {\n      return new Error(\"Cannot read from primary when secondary only specified\");\n    }\n  }\n\n  // Return no error\n  return null;\n}\n\n/**\n * @ignore\n */\nServer.prototype.checkoutReader = function() {\n  // Check if are allowed to do a checkout (if we try to use an arbiter f.ex)\n  var result = canCheckoutReader(this);\n  // If the result is null check out a writer\n  if(result == null && this.connectionPool != null) {\n    return this.connectionPool.checkoutConnection();\n  } else if(result == null) {\n    return null;\n  } else {\n    return result;\n  }\n}\n\n/**\n * @ignore\n */\nServer.prototype.enableRecordQueryStats = function(enable) {\n  this.recordQueryStats = enable;\n}\n\n/**\n * Internal statistics object used for calculating average and standard devitation on\n * running queries\n * @ignore\n */\nvar RunningStats = function() {\n  var self = this;\n  this.m_n = 0;\n  this.m_oldM = 0.0;\n  this.m_oldS = 0.0;\n  this.m_newM = 0.0;\n  this.m_newS = 0.0;\n\n  // Define getters\n  Object.defineProperty(this, \"numDataValues\", { enumerable: true\n    , get: function () { return this.m_n; }\n  });\n\n  Object.defineProperty(this, \"mean\", { enumerable: true\n    , get: function () { return (this.m_n > 0) ? this.m_newM : 0.0; }\n  });\n\n  Object.defineProperty(this, \"variance\", { enumerable: true\n    , get: function () { return ((this.m_n > 1) ? this.m_newS/(this.m_n - 1) : 0.0); }\n  });\n\n  Object.defineProperty(this, \"standardDeviation\", { enumerable: true\n    , get: function () { return Math.sqrt(this.variance); }\n  });\n\n  Object.defineProperty(this, \"sScore\", { enumerable: true\n    , get: function () {\n      var bottom = this.mean + this.standardDeviation;\n      if(bottom == 0) return 0;\n      return ((2 * this.mean * this.standardDeviation)/(bottom));\n    }\n  });\n}\n\n/**\n * @ignore\n */\nRunningStats.prototype.push = function(x) {\n  // Update the number of samples\n  this.m_n = this.m_n + 1;\n  // See Knuth TAOCP vol 2, 3rd edition, page 232\n  if(this.m_n == 1) {\n    this.m_oldM = this.m_newM = x;\n    this.m_oldS = 0.0;\n  } else {\n    this.m_newM = this.m_oldM + (x - this.m_oldM) / this.m_n;\n    this.m_newS = this.m_oldS + (x - this.m_oldM) * (x - this.m_newM);\n\n    // set up for next iteration\n    this.m_oldM = this.m_newM;\n    this.m_oldS = this.m_newS;\n  }\n}\n\n/**\n * @ignore\n */\nObject.defineProperty(Server.prototype, \"autoReconnect\", { enumerable: true\n  , get: function () {\n      return this.options['auto_reconnect'] == null ? false : this.options['auto_reconnect'];\n    }\n});\n\n/**\n * @ignore\n */\nObject.defineProperty(Server.prototype, \"connection\", { enumerable: true\n  , get: function () {\n      return this.internalConnection;\n    }\n  , set: function(connection) {\n      this.internalConnection = connection;\n    }\n});\n\n/**\n * @ignore\n */\nObject.defineProperty(Server.prototype, \"master\", { enumerable: true\n  , get: function () {\n      return this.internalMaster;\n    }\n  , set: function(value) {\n      this.internalMaster = value;\n    }\n});\n\n/**\n * @ignore\n */\nObject.defineProperty(Server.prototype, \"primary\", { enumerable: true\n  , get: function () {\n      return this;\n    }\n});\n\n/**\n * Getter for query Stats\n * @ignore\n */\nObject.defineProperty(Server.prototype, \"queryStats\", { enumerable: true\n  , get: function () {\n      return this._state.runtimeStats.queryStats;\n    }\n});\n\n/**\n * @ignore\n */\nObject.defineProperty(Server.prototype, \"runtimeStats\", { enumerable: true\n  , get: function () {\n      return this._state.runtimeStats;\n    }\n});\n\n/**\n * Get Read Preference method\n * @ignore\n */\nObject.defineProperty(Server.prototype, \"readPreference\", { enumerable: true\n  , get: function () {\n      if(this._readPreference == null && this.readSecondary) {\n        return Server.READ_SECONDARY;\n      } else if(this._readPreference == null && !this.readSecondary) {\n        return Server.READ_PRIMARY;\n      } else {\n        return this._readPreference;\n      }\n    }\n});\n\n/**\n * @ignore\n */\nexports.Server = Server;\n"]],"start1":0,"start2":0,"length1":0,"length2":32476}]],"length":32476}
