{"ts":1353251189526,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var utils = require('./connection_utils'),\n  inherits = require('util').inherits,\n  net = require('net'),\n  EventEmitter = require('events').EventEmitter,\n  inherits = require('util').inherits,\n  MongoReply = require(\"../responses/mongo_reply\").MongoReply,\n  Connection = require(\"./connection\").Connection;\n\nvar ConnectionPool = exports.ConnectionPool = function(host, port, poolSize, bson, socketOptions) {\n  if(typeof host !== 'string' || typeof port !== 'number') throw \"host and port must be specified [\" + host + \":\"  + port + \"]\";\n  // Set up event emitter\n  EventEmitter.call(this);\n  // Keep all options for the socket in a specific collection allowing the user to specify the\n  // Wished upon socket connection parameters\n  this.socketOptions = typeof socketOptions === 'object' ? socketOptions : {};\n  this.socketOptions.host = host;\n  this.socketOptions.port = port;\n  this.socketOptions.domainSocket = false;\n  this.bson = bson;\n  // PoolSize is always + 1 for special reserved \"measurment\" socket (like ping, stats etc)\n  this.poolSize = poolSize;\n  this.minPoolSize = Math.floor(this.poolSize / 2) + 1;\n\n  // Check if the host is a socket\n  if(host.match(/^\\//)) this.socketOptions.domainSocket = true;\n\n  // Set default settings for the socket options\n  utils.setIntegerParameter(this.socketOptions, 'timeout', 0);\n  // Delay before writing out the data to the server\n  utils.setBooleanParameter(this.socketOptions, 'noDelay', true);\n  // Delay before writing out the data to the server\n  utils.setIntegerParameter(this.socketOptions, 'keepAlive', 0);\n  // Set the encoding of the data read, default is binary == null\n  utils.setStringParameter(this.socketOptions, 'encoding', null);\n  // Allows you to set a throttling bufferSize if you need to stop overflows\n  utils.setIntegerParameter(this.socketOptions, 'bufferSize', 0);\n\n  // Internal structures\n  this.openConnections = [];\n  // Assign connection id's\n  this.connectionId = 0;\n\n  // Current index for selection of pool connection\n  this.currentConnectionIndex = 0;\n  // The pool state\n  this._poolState = 'disconnected';\n  // timeout control\n  this._timeout = false;\n}\n\ninherits(ConnectionPool, EventEmitter);\n\nConnectionPool.prototype.setMaxBsonSize = function(maxBsonSize) {\n  if(maxBsonSize == null){\n    maxBsonSize = Connection.DEFAULT_MAX_BSON_SIZE;\n  }\n\n  for(var i = 0; i < this.openConnections.length; i++) {\n    this.openConnections[i].maxBsonSize = maxBsonSize;\n  }\n}\n\n// Start a function\nvar _connect = function(_self) {\n  return new function() {\n    // Create a new connection instance\n    var connection = new Connection(_self.connectionId++, _self.socketOptions);\n    // Set logger on pool\n    connection.logger = _self.logger;\n    // Connect handler\n    connection.on(\"connect\", function(err, connection) {\n      // Add connection to list of open connections\n      _self.openConnections.push(connection);\n      // If the number of open connections is equal to the poolSize signal ready pool\n      if(_self.openConnections.length === _self.poolSize && _self._poolState !== 'disconnected') {\n        // Set connected\n        _self._poolState = 'connected';\n        // Emit pool ready\n        _self.emit(\"poolReady\");\n      } else if(_self.openConnections.length < _self.poolSize) {\n        // We need to open another connection, make sure it's in the next\n        // tick so we don't get a cascade of errors\n        process.nextTick(function() {\n          _connect(_self);\n        });\n      }\n    });\n\n    var numberOfErrors = 0\n\n    // Error handler\n    connection.on(\"error\", function(err, connection) {\n      numberOfErrors++;\n      // If we are already disconnected ignore the event\n      if(_self._poolState != 'disconnected' && _self.listeners(\"error\").length > 0) {\n        _self.emit(\"error\", err);\n      }\n\n      // Set disconnected\n      _self._poolState = 'disconnected';\n      // Stop\n      _self.stop();\n    });\n\n    // Close handler\n    connection.on(\"close\", function() {\n      // If we are already disconnected ignore the event\n      if(_self._poolState !== 'disconnected' && _self.listeners(\"close\").length > 0) {\n        _self.emit(\"close\");\n      }\n      // Set disconnected\n      _self._poolState = 'disconnected';\n      // Stop\n      _self.stop();\n    });\n\n    // Timeout handler\n    connection.on(\"timeout\", function(err, connection) {\n      // If we are already disconnected ignore the event\n      if(_self._poolState !== 'disconnected' && _self.listeners(\"timeout\").length > 0) {\n        _self.emit(\"timeout\", err);\n      }\n      // Set disconnected\n      _self._poolState = 'disconnected';\n      // Stop\n      _self.stop();\n    });\n\n    // Parse error, needs a complete shutdown of the pool\n    connection.on(\"parseError\", function() {\n      // If we are already disconnected ignore the event\n      if(_self._poolState !== 'disconnected' && _self.listeners(\"parseError\").length > 0) {\n        _self.emit(\"parseError\", new Error(\"parseError occured\"));\n      }\n\n      _self.stop();\n    });\n\n    connection.on(\"message\", function(message) {\n      _self.emit(\"message\", message);\n    });\n\n    // Start connection in the next tick\n    connection.start();\n  }();\n}\n\n\n// Start method, will throw error if no listeners are available\n// Pass in an instance of the listener that contains the api for\n// finding callbacks for a given message etc.\nConnectionPool.prototype.start = function() {\n  var markerDate = new Date().getTime();\n  var self = this;\n\n  if(this.listeners(\"poolReady\").length == 0) {\n    throw \"pool must have at least one listener ready that responds to the [poolReady] event\";\n  }\n\n  // Set pool state to connecting\n  this._poolState = 'connecting';\n  this._timeout = false;\n\n  _connect(self);\n}\n\n// Restart a connection pool (on a close the pool might be in a wrong state)\nConnectionPool.prototype.restart = function() {\n  // Close all connections\n  this.stop(false);\n  // Now restart the pool\n  this.start();\n}\n\n// Stop the connections in the pool\nConnectionPool.prototype.stop = function(removeListeners) {\n  removeListeners = removeListeners == null ? true : removeListeners;\n  // Set disconnected\n  this._poolState = 'disconnected';\n\n  // Clear all listeners if specified\n  if(removeListeners) {\n    this.removeAllEventListeners();\n  }\n\n  // Close all connections\n  for(var i = 0; i < this.openConnections.length; i++) {\n    this.openConnections[i].close();\n  }\n\n  // Clean up\n  this.openConnections = [];\n}\n\n// Check the status of the connection\nConnectionPool.prototype.isConnected = function() {\n  return this._poolState === 'connected';\n}\n\n// Checkout a connection from the pool for usage, or grab a specific pool instance\nConnectionPool.prototype.checkoutConnection = function(id) {\n  var index = (this.currentConnectionIndex++ % (this.openConnections.length));\n  var connection = this.openConnections[index];\n  return connection;\n}\n\nConnectionPool.prototype.getAllConnections = function() {\n  return this.openConnections;\n}\n\n// Remove all non-needed event listeners\nConnectionPool.prototype.removeAllEventListeners = function() {\n  this.removeAllListeners(\"close\");\n  this.removeAllListeners(\"error\");\n  this.removeAllListeners(\"timeout\");\n  this.removeAllListeners(\"connect\");\n  this.removeAllListeners(\"end\");\n  this.removeAllListeners(\"parseError\");\n  this.removeAllListeners(\"message\");\n  this.removeAllListeners(\"poolReady\");\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":7389}]],"length":7389}
